"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import dateutil.parser
from .checkstatus import CheckStatus
from dataclasses_json import Undefined, dataclass_json
from datetime import datetime
from ding import utils
from enum import Enum
from typing import List, Optional, Union


class AuthenticationStatusResponseDeviceType(str, Enum):
    r"""The type of device the user is using."""
    ANDROID = 'ANDROID'
    IOS = 'IOS'
    IPADOS = 'IPADOS'
    TVOS = 'TVOS'
    WEB = 'WEB'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Signals:
    r"""[Signals](/guides/prevent-fraud#signals) are data points used to distinguish between fraudulent and legitimate users."""
    ip: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ip'), 'exclude': lambda f: f is None }})
    r"""The IP address of the user's device."""
    device_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('device_id'), 'exclude': lambda f: f is None }})
    r"""Unique identifier for the user's device. For Android, this corresponds to the `ANDROID_ID` and for iOS, this corresponds to the `identifierForVendor`."""
    device_type: Optional[AuthenticationStatusResponseDeviceType] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('device_type'), 'exclude': lambda f: f is None }})
    r"""The type of device the user is using."""
    app_version: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('app_version'), 'exclude': lambda f: f is None }})
    r"""The version of your application."""
    app_realm: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('app_realm'), 'exclude': lambda f: f is None }})
    r"""The Android SMS Retriever API hash code that identifies your app. This allows you to automatically retrieve and fill the OTP code on Android devices."""
    os_version: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('os_version'), 'exclude': lambda f: f is None }})
    r"""The version of the user's device operating system."""
    device_model: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('device_model'), 'exclude': lambda f: f is None }})
    r"""The model of the user's device."""
    is_returning_user: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('is_returning_user'), 'exclude': lambda f: f is None }})
    r"""This signal should do more than just confirm if a user is returning to your app; it should provide a higher level of trust, indicating that the user is genuine. For more details, refer to [Signals](/guides/prevent-fraud#signals)."""
    



class BalanceUpdateType(str, Enum):
    UNKNOWN = 'unknown'
    AUTHENTICATION = 'authentication'
    ATTEMPT = 'attempt'
    ATTEMPT_PENDING = 'attempt_pending'
    ATTEMPT_SUCCESS = 'attempt_success'
    AUTHENTICATION_PENDING = 'authentication_pending'
    AUTHENTICATION_SUCCESS = 'authentication_success'


class AuthenticationStatusResponseSchemasEventsType(str, Enum):
    r"""The type of the event."""
    ATTEMPT = 'attempt'
    CHECK = 'check'
    DELIVERY_STATUS = 'delivery_status'
    BALANCE_UPDATE = 'balance_update'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class BalanceUpdate:
    balance_update_type: Optional[BalanceUpdateType] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('balance_update_type'), 'exclude': lambda f: f is None }})
    amount: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('amount'), 'exclude': lambda f: f is None }})
    r"""The amount of the balance update."""
    type: Optional[AuthenticationStatusResponseSchemasEventsType] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""The type of the event."""
    created_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('created_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'exclude': lambda f: f is None }})
    



class AuthenticationStatusResponseSchemasStatus(str, Enum):
    r"""The status of the delivery. Possible values are:
      * `unknown` - The status of the delivery is unknown.
      * `submitted` - The message has been submitted to the carrier.
      * `in_transit` - The message is in transit to the recipient.
      * `delivered` - The message has been delivered to the recipient.
      * `undeliverable` - The message could not be delivered to the recipient.
    """
    UNKNOWN = 'unknown'
    SUBMITTED = 'submitted'
    IN_TRANSIT = 'in_transit'
    DELIVERED = 'delivered'
    UNDELIVERABLE = 'undeliverable'


class AuthenticationStatusResponseSchemasType(str, Enum):
    r"""The type of the event."""
    ATTEMPT = 'attempt'
    CHECK = 'check'
    DELIVERY_STATUS = 'delivery_status'
    BALANCE_UPDATE = 'balance_update'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class DeliveryStatus:
    status: Optional[AuthenticationStatusResponseSchemasStatus] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})
    r"""The status of the delivery. Possible values are:
      * `unknown` - The status of the delivery is unknown.
      * `submitted` - The message has been submitted to the carrier.
      * `in_transit` - The message is in transit to the recipient.
      * `delivered` - The message has been delivered to the recipient.
      * `undeliverable` - The message could not be delivered to the recipient.
    """
    attempt_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('attempt_id'), 'exclude': lambda f: f is None }})
    r"""The ID of the attempt."""
    attempt_number: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('attempt_number'), 'exclude': lambda f: f is None }})
    r"""The attempt number."""
    originated_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('originated_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'exclude': lambda f: f is None }})
    r"""The date and time from the provider."""
    type: Optional[AuthenticationStatusResponseSchemasType] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""The type of the event."""
    created_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('created_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'exclude': lambda f: f is None }})
    



class AuthenticationStatusResponseType(str, Enum):
    r"""The type of the event."""
    ATTEMPT = 'attempt'
    CHECK = 'check'
    DELIVERY_STATUS = 'delivery_status'
    BALANCE_UPDATE = 'balance_update'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Check:
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""The ID of the check."""
    code: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('code'), 'exclude': lambda f: f is None }})
    r"""The code that was checked."""
    status: Optional[CheckStatus] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})
    type: Optional[AuthenticationStatusResponseType] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""The type of the event."""
    created_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('created_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'exclude': lambda f: f is None }})
    



class Capability(str, Enum):
    r"""The capability of the attempt."""
    RCS = 'rcs'
    TEXT = 'text'
    WHATSAPP = 'whatsapp'
    VIBER = 'viber'


class AuthenticationStatusResponseStatus(str, Enum):
    r"""The status of the attempt. Possible values are:
      * `pending` - The attempt is pending.
      * `delivered` - The attempt was delivered.
      * `failed` - The attempt failed.
      * `rate_limited` - The authentication was rate limited and cannot be retried.
      * `expired` - The authentication has expired and cannot be retried.
    """
    PENDING = 'pending'
    DELIVERED = 'delivered'
    FAILED = 'failed'
    RATE_LIMITED = 'rate_limited'
    EXPIRED = 'expired'


class Type(str, Enum):
    r"""The type of the event."""
    ATTEMPT = 'attempt'
    CHECK = 'check'
    DELIVERY_STATUS = 'delivery_status'
    BALANCE_UPDATE = 'balance_update'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Attempt:
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""The ID of the attempt."""
    content: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('content'), 'exclude': lambda f: f is None }})
    r"""The content of the attempt."""
    sender_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sender_id'), 'exclude': lambda f: f is None }})
    r"""The sender ID of the attempt."""
    capability: Optional[Capability] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('capability'), 'exclude': lambda f: f is None }})
    r"""The capability of the attempt."""
    attempt_number: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('attempt_number'), 'exclude': lambda f: f is None }})
    r"""The attempt number."""
    status: Optional[AuthenticationStatusResponseStatus] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})
    r"""The status of the attempt. Possible values are:
      * `pending` - The attempt is pending.
      * `delivered` - The attempt was delivered.
      * `failed` - The attempt failed.
      * `rate_limited` - The authentication was rate limited and cannot be retried.
      * `expired` - The authentication has expired and cannot be retried.
    """
    type: Optional[Type] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""The type of the event."""
    created_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('created_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'exclude': lambda f: f is None }})
    



@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class AuthenticationStatusResponse:
    uuid: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('uuid'), 'exclude': lambda f: f is None }})
    r"""The UUID of the corresponding authentication."""
    phone_number: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('phone_number'), 'exclude': lambda f: f is None }})
    r"""An E.164 formatted phone number."""
    template_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('template_id'), 'exclude': lambda f: f is None }})
    r"""The template id associated with the message content variant to be sent."""
    correlation_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('correlation_id'), 'exclude': lambda f: f is None }})
    r"""A unique, user-defined identifier that will be included in webhook events."""
    created_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('created_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'exclude': lambda f: f is None }})
    signals: Optional[Signals] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('signals'), 'exclude': lambda f: f is None }})
    r"""[Signals](/guides/prevent-fraud#signals) are data points used to distinguish between fraudulent and legitimate users."""
    events: Optional[List[Events]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('events'), 'exclude': lambda f: f is None }})
    r"""Represents a collection of events that occur during the authentication process. Each event captures specific actions and outcomes related to the authentication attempts, checks, delivery statuses, and balance updates. The array can contain different types of events, each with its own structure and properties."""
    


Events = Union[Attempt, Check, DeliveryStatus, BalanceUpdate]
